module GraphicsJS
  class Stage
    include Native

    def initialize(id, width, height)
      super `acgraph.create(#{id},#{width}, #{height})`
    end
    def h
      Browser::DOM::Element.new(`#{self.to_n}.h`)
    end
    alias_native :rect, :rect
    alias_native :circle, :circle
    alias_native :path, :path
    alias_native :moveTo, :moveTo
    alias_native :lineTo, :lineTo
    alias_native :suspend, :suspend
    alias_native :resume, :resume
  end
end

class Browser::Event::TouchList
  class Touch
    include Native
    attr_reader :identifier, :screenX, :screenY, :clientX, :clientY, :pageX, :pageY, :target, :radiusX, :radiusY, :rotationAngle, :force

    def initialize(native)
      super(native)
      @identifier = `#{native}.identifier`
      @screenX = `#{native}.screenX`
      @screenY = `#{native}.screenY`
      @clientX = `#{native}.clientX`
      @clientY = `#{native}.clientY`
      @pageX = `#{native}.pageX`
      @pageY = `#{native}.pageY`
      @target = `#{native}.target`
      @radiusX = `#{native}.radiusX`
      @radiusY = `#{native}.radiusY`
      @rotationAngle = `#{native}.rotationAngle`
      @force = `#{native}.force`
    end
  end

  include Enumerable
  include Native

  def initialize(native)
    super(native)
  end
  
  def each
    Native::Array.new(self.to_n).each do |x|
      yield Touch.new(x.to_n)
    end
  end
end

class Browser::Event::Touch
  def changedTouches
    return TouchList.new(`#{self.to_n}.changedTouches`)
  end
end

class Touch
  def initialize(elem)
    @elem = elem
    @ongoingTouches = []
    @onTouchStart = nil
    @onTouchEnd = nil
    @onTouchCancel = nil
    @onTouchMove = nil
  end

  def ongoingTouchIndexById(idToFind)
    return @ongoingTouches.index {|x| x.identifier == idToFind }
  end

  def touchStartHandler(e)
    e.prevent()
    e.changedTouches.each do |x| 
      @ongoingTouches << x
      @onTouchStart.call(x) if @onTouchStart != nil
    end
  end

  def touchEndHandler(e)
    e.prevent()
    e.changedTouches.each do |x| 
      index = ongoingTouchIndexById(x.identifier)
      if index != nil
        t = @ongoingTouches[index]
        @ongoingTouches.delete_at(index) 
        @onTouchEnd.call(t) if @onTouchEnd != nil
      end
    end
  end

  def touchCancelHandler(e)
    e.prevent()
    e.changedTouches.each do |x| 
      index = ongoingTouchIndexById(x.identifier)
      if index != nil
        t = @ongoingTouches[index]
        @ongoingTouches.delete_at(index) 
        @onTouchCancel.call(t) if @onTouchCancel != nil
      end
    end
  end

  def touchMoveHandler(e)
    e.prevent()
    e.changedTouches.each do |x| 
      index = ongoingTouchIndexById(x.identifier)
      if index != nil
        t1 = x
        t2 = @ongoingTouches[index]
        @ongoingTouches[index] = t1
        @onTouchMove.call(t1,t2) if @onTouchMove != nil
      end
    end
  end

  def startCapture
    @elem.on("touchstart", false) { |t| touchStartHandler(t) } 
    @elem.on("touchend", false) { |t| touchEndHandler(t) }
    @elem.on("touchcancel", false) { |t| touchCancelHandler(t) }
    @elem.on("touchmove", false) { |t| touchMoveHandler(t) }
  end

  def onTouchStart(&block)
    @onTouchStart = block
  end

  def onTouchEnd(&block)
    @onTouchEnd = block
  end

  def onTouchCancel(&block)
    @onTouchCancel = block
  end

  def onTouchMove(&block)
    @onTouchMove = block
  end
end

WIDTH = 640
HEIGHT = 480
COUNT = 30

stage = GraphicsJS::Stage.new('stage-container', WIDTH, HEIGHT)

balls = COUNT.times.map do |i|
  ball = stage.circle(400, 300, 10).fill('#ff0000')
  ball.dx = Math.cos(i*Math::PI/(COUNT/2))*5;
  ball.dy = Math.sin(i*Math::PI/(COUNT/2))*5;
  ball.disablePointerEvents
  ball
end

player = stage.circle(WIDTH/2, HEIGHT/2, 10).fill('#00ff00')

touch = Touch.new(stage.h)
identifier = nil
touch.onTouchStart do |t|
  if identifier == nil
    identifier = t.identifier
    player.centerX(t.pageX-stage.h.position.x)
    player.centerY(t.pageY-stage.h.position.y)
  end
end
touch.onTouchMove do |t|
  if identifier == t.identifier
    player.centerX(t.pageX-stage.h.position.x)
    player.centerY(t.pageY-stage.h.position.y)
  end
end
touch.onTouchEnd do |t|
  if identifier == t.identifier
    identifier = nil
  end
end
touch.startCapture

def hitcheck(a,b)
  ax = a.centerX()
  ay = a.centerY()
  ar = a.radius()
  bx = b.centerX()
  by = b.centerY()
  br = b.radius()
  return ((bx-ax) ** 2 + (by-ay) ** 2) < (ar + br) ** 2
end

delay = Browser::Delay.new($window, 0.02) do 
  stage.suspend()
  player.fill('#00ff00')
  balls.each do |ball|
    if hitcheck(player, ball)
      player.fill('#0000ff')
    end
    nx = ball.centerX() + ball.dx
    ny = ball.centerY() + ball.dy
    if nx < 0 then
      nx = 0
      ball.dx *= -1
    elsif nx > WIDTH then
      nx = WIDTH
      ball.dx *= -1
    end
    if ny < 0 then
      ny = 0
      ball.dy *= -1
    elsif ny > HEIGHT then
      ny = HEIGHT
      ball.dy *= -1
    end
    ball.centerX( nx )
    ball.centerY( ny )
  end
  stage.resume()
  delay.start
end
delay.start
