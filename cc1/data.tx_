CPUが変数をどう読み書きするか？

CPUはC言語（に限らず数多の高級言語）を直接理解できない。
そのため、変数名や関数名といった人間のわかりやすい「名前」を理解できない。

例：U4  v = 0x12345678;    ????
        v = v + 3;         ????

そのため、多くの高級言語はコンパイラによってCPUが理解できる言語（機械語）に翻訳する
機械語には様々な種類があるが、ほぼ全ての機械語は次のような命令を持っている


・メモリに対する読み書きの機能
　　メモリのアドレス【　　　】から始まるNバイトの値をCPU内部に読み取る
　　Nバイトの値【　　　】をメモリのアドレス【　　　】に書き込む

　　【】には定数値、もしくは、「CPUの内部の値」
　　Nは1,2,4など予め命令で決められている定数


・四則演算機能に代表される数値演算の機能
　Nバイトの値【　　　】とNバイトの値【　　　】の加算/減算/乗算/除算/剰余算/etc... の結果をCPU内部に作る
　　【】には定数値、もしくは、「CPUの内部の値」
　　Nは1,2,4など予め命令で決められている定数

　変数の読み書きや、変数を用いた計算などはすべてこれらを使う形で表現される

変数の読み書きに必要なのは変数が割り当てられているメモリ上の領域を示すアドレスと、どれくらいの大きさを占めているかという情報であるが、
素晴らしいことにコンパイラは翻訳する際に自動的に変数のアドレスを決めてくれる。

v = ... の場合、
コンパイラ　＜　変数vのアドレスは 0x4000 に【独断で】決めました！
となる。


また、多くのCPUは計算で使える値はCPU内部の値もしくは定数値のみという制約がある。
そのため、c = a + bを計算する場合は

1. 変数aの値をCPU内部に読み取る
2. 変数bの値をCPU内部に読み取る
3. 【読み取った2つの値の加算】の結果をCPU内部に作る
4. CPU内部にある足し合わせた結果をaに書き込む

という手順が必要になる。


これらを踏まえて、前述の例をコンパイラがどのように機械語に翻訳するかを観てみよう。

１．コンパイラは変数のアドレスを決定する
　　この例では、ｖのアドレスを0x4000に決める（これはコンパイラがトップダウン的に決める）

２．U4  v = 0x12345678;　に対応する命令を作る。
　　これは「４バイト幅の変数 v の領域に４バイトの値 0x12345678 を書き込む」という処理である。
　　前述の通り、CPUは「変数 v の領域」を理解できないため、コンパイラはここをアドレス値に置き換える。すなわち、
　　「4バイトの値【0x12345678】をメモリ上のアドレス 【0x4000】 に書き込む」を作る

３．v = v + 3;　に対応する命令を作る。
　　これは「変数 v の値を取得し、それに定数3を加算した値で変数 v を更新する」という処理だが、これは３つのステップの処理に分割できる。

　　1. 変数 v の値をCPU内部に読み取る
　　2. 読み取った値と定数の３を加算する
　　3. 合計結果を変数 v の領域に書き込む

　　1 の処理は先ほどの変数読み取りの命令を使って
　　　「メモリのアドレス 【0x4000】 から始まる4バイトの値を読み取る」
　　とできる

　　２の処理は足し算命令を使って
　　　「【読み取った値と定数の３の加算】の結果結果をCPUに格納する。」
　　とできる

　　３の処理は先ほどの変数書き込みの命令を使って
　　　「4バイトの値【（CPU内部にある加算結果）】をメモリ上のアドレス 【0x4000】 に書き込むに格納する。」
　　とできる

この結果、コンパイラは次のような命令を出力する

「4バイトの値【0x12345678】をメモリ上のアドレス 【0x4000】 に書き込む」
「メモリのアドレス 【0x4000】 から始まる4バイトの値を読み取る」
「【読み取った値と定数の３の加算】の結果結果をCPUに格納する。」
「4バイトの値【（CPU内部にある加算結果）】をメモリ上のアドレス 【0x4000】 に書き込むに格納する。」

それでは実際にコンパイラが作った命令を手作業で実行してみよう

メモリ
       +0 +1 +2 +3 +4 +5 +6 +7
0x4000 ?? ?? ?? ?? ?? ?? ?? ??

CPU内部の値：[]

　「4バイトの値【0x12345678】をメモリ上のアドレス 【0x4000】 に書き込む」
　「メモリのアドレス 【0x4000】 から始まる4バイトの値を読み取る」
　「【読み取った値＋定数の３】の結果をCPUに格納する。」
　「4バイトの値【（CPU内部にある加算結果）】をメモリ上のアドレス 【0x4000】 に書き込むに格納する。」

（実行アニメーション）

----
では練習問題を解いてみましょう

------

構造体/共用体の場合

構造体の場合は単純型の変数のアドレス計算が少し増えるだけです。

struct Data { 
  U8   x; /* バイトオフセットは 0 */
  U16  y; /* バイトオフセットは 2 */
  U8   z; /* バイトオフセットは 5 */
};

struct Data s;     /* 構造体 s の先頭要素のアドレスは 0x4014 です */

s.y = 2;


これは「Data構造体型の変数 s のメンバ y の領域に２バイトの値 0x0002 を書き込む」という処理である。
単純型の例と同様に、CPUは「Data構造体型の変数 s のメンバ y の領域」を理解できないため、コンパイラはここを「構造体のメンバのアドレスの計算式」で求めたアドレス値に置き換えます。

Data構造体型の変数 s のメンバ y のアドレスは
　構造体型変数 s のアドレス＋メンバ y のバイトオフセット
で求めることが出来ます。

ここで、構造体型変数 s のアドレスはコンパイラが 0x4014 だと決めてくれています。また、バイトオフセットも2だと計算してくれます。この結果を使うとData構造体型の変数 s のメンバ y のアドレスはこのようになります。

　0x4014＋2 = 0x4016

よってコンパイラは「2バイトの値【0x0002】をメモリ上のアドレス 【0x4016】 に書き込む」という機械語を作ります。


共用体の場合は構造体と違い、単純型の場合とアドレス計算が変わりません。
メンバのバイトオフセットは常に０であるため、先ほどの式からバイトオフセット計算を消すことができます。
その結果、共用体の先頭アドレスがそのまま要素のアドレスになるからです。
一方、メンバの型は読み書きする大きさになります。

それでは実際にコンパイラが作った命令を手作業で実行してみよう
（実行アニメーション）

---

練習問題
次の情報を元に配列変数の読み書きをする機械語に翻訳してください。

------

配列型の場合(1)

配列型の変数を読み書きする場合は少しだけ複雑だが、考え方は同じ。

配列 a の ｎ番目の要素のアドレスは　配列 a の先頭の要素のアドレス＋配列の要素の大きさ×ｎ　で求めることができました。

これをふまえて次のコードをコンパイラがどのように機械語に翻訳するか実際に観てみましょう。

U2 a[10];    /* 配列 a の先頭要素のアドレスは 0x4020 です */

a[3] = 0x270F;

これは「要素型が２バイトである配列 a の3番目の領域に２バイトの値 0x270F を書き込む」という処理である。
これを先ほどの変数への代入と同じ考え方で翻訳しようとすると、

前述の通り、CPUは「配列 a の3番目の領域」を理解できないため、コンパイラはここを先ほどの配列の要素のアドレスを求める式を使ってアドレス値を求めます。
　　a[3]のアドレス = 配列 a の先頭の要素のアドレス＋配列の要素の大きさ×ｎ
　　　　　　　　　 = 0x4020＋2×3
　　　　　　　　　 = 0x4026 

　よって作られる機械語は次のようになります。
　　「2バイトの値【0x270F】をメモリ上のアドレス 【0x4026】 に書き込む」

それでは実際にコンパイラが作った命令を手作業で実行してみよう
（実行アニメーション）

----


配列型の場合(2)
さて、これでめでたしめでたしではありません。
前述の例では添え字が定数であるため、読み書きする要素は固定でしたが、
配列型を使う最大のメリットは、プログラムの実行中に[]の中を変化させることができることです。

では次のような例を考えてみましょう。

S4 i = ...;  /* 変数 i のアドレスは 0x4008 です */
U2 a[10];    /* 配列 a の先頭要素のアドレスは 0x4020 です */

としたときに

a[i] = 0x0000;

はどのように翻訳されるでしょうか？

先ほどと違って、配列aの添え字が定数ではなく、変数です。
この場合、コンパイラは翻訳時にアドレス値を計算することができませ。そこで、コンパイラは前述の2つの例の合わせ技を使い、途中にCPUに配列の要素のアドレスの計算をさせる処理を入れて翻訳します。

ではその手順を観てみましょう。

まずは処理を分解するとこのようになります。

　　1．「【配列 a の i 番目の要素のアドレスを計算】の結果をCPUに格納する。」
　　2. 「2バイトの値【0x270F】をメモリ上のアドレス 【（CPU内部にあるアドレス計算結果）】 に書き込む」

ここで１の中のアドレス計算を前述の配列の要素のアドレス計算式で置き換えます

　　1．「【配列 a の先頭の要素のアドレス＋配列の要素の大きさ× i 】の結果をCPUに格納する。」
　　2. 「2バイトの値【0x270F】をメモリ上のアドレス 【（CPU内部にあるアドレス計算結果）】 に書き込む」

配列 a の先頭の要素のアドレスはコンパイラが 0x4020 だと決めているので、0x4020 という定数値 に置き換えることが出来ます。

　　1．「【0x4020＋配列の要素の大きさ× i 】の結果をCPUに格納する。」
　　2. 「2バイトの値【0x270F】をメモリ上のアドレス 【（CPU内部にあるアドレス計算結果）】 に書き込む」

さらに、配列の要素型の大きさは２バイトであるとわかっているため、これも2という定数値に置き換えることが出来ます。

　　1．「【0x4020＋2× i 】の結果をCPUに格納する。」
　　2. 「2バイトの値【0x270F】をメモリ上のアドレス 【（CPU内部にあるアドレス計算結果）】 に書き込む」

そして、変数 i の値はメモリからの読み出しが必要になるので、先頭に変数 i の値を読み出す処理を追加します。

　　1. 「変数 i の値をCPU内部に読み取る」
　　2．「【0x4020＋2× 読み取り結果 】の結果をCPUに格納する。」
　　3. 「2バイトの値【0x270F】をメモリ上のアドレス 【（CPU内部にあるアドレス計算結果）】 に書き込む」

変数 i のアドレスはコンパイラが 0x4008 だと決めているので、0x4008 という定数値 に置き換えることが出来ます。

　　1. 「メモリのアドレス 【0x4008】 から始まる4バイト の値を読み取る」
　　2．「【0x4020＋2× 読み取り結果 】の結果をCPUに格納する。」
　　3. 「2バイトの値【0x270F】をメモリ上のアドレス 【（CPU内部にあるアドレス計算結果）】 に書き込む」

以上で翻訳することができました。

それでは実際にコンパイラが作った命令を手作業で実行してみよう
（実行アニメーション）

---

練習問題
次の情報を元に配列変数の読み書きをする機械語に翻訳してください。

----

特定のアドレスを読み書きしたい場合

皆さんが業務で使用しているマイコンに限らず、CPUには計算以外の機能を実現するための部品が接続されています。
それの代表的なものとしては「タイマー機能」、「通信機能」、「汎用IO機能」があります。

これらはCPUの外側にあるため、CPUと通信するときには二つの方法が使われます。

１．外部通信用の特別な命令を使う
２．特定のメモリアドレスを外部の部品との通信用として使う

１はメモリが一般化する前の大昔のCPUや、メモリは最小限しか積まない極小規模のCPUなどで使われている「ポートマップドＩ／Ｏ」と呼ばれる方法です。
２は現在のCPUが使っている方法で「メモリマップドＩ／Ｏ」と呼ばれる方法です。

１の方法を使う場合は、コンパイラが用意している特別な命令に対応する関数を呼び出せば通信することができるため、使うのは簡単なのですが、この命令のために専用の外部通信用の回路をＣＰＵの中に作らなければならないため、ＣＰＵが複雑になってしまい高速化・低価格化の障害となることが多かったため、ＣＰＵの高性能化に伴って廃れていきました。

２の方法はメモリアドレスの読み書きが外部の部品との通信になるため、ＣＰＵの構造が簡略化でき、高速化・低価格化を行いやすくなります。

しかし、２の方法では一つ問題が起きます。それは、外部部品との通信をするためには「特定のアドレス」を読み書きしなければならないということです。


たとえば、タイマー機能が繋がっているアドレスが 0x1000 で一度に読み書きできるサイズが１バイトだとしましょう。

機械語でこのアドレスを使ってタイマー機能と通信する場合、送信と受信はそれぞれ次のように記述できます。

１バイトの値の送信
「1バイトの値【0x??】をメモリ上のアドレス 【0x1000】 に書き込む」

１バイトの値の受信
「メモリのアドレス 【0x1000】 から始まる1バイト の値を読み取る」



----



メモリ上の特定のアドレスを読み書きすることは機械語では簡単にできます。
ではこれをＣ言語で記述するにはどうしたらよいでしょうか？

前述のように、Ｃ言語では変数は「コンパイラによって勝手に」アドレスが割り当てられます。変数に割り当てられるアドレスをプログラマが指定することはＣ言語の標準機能の範囲ではできません※。

※皆さんが業務で使用しているルネサス製のＣコンパイラでは #pragma address 変数名,アドレス値 とすることで、これを指定できますが、これはルネサス製のＣコンパイラの独自機能です。

あるアドレスを計算によって求めて読み書きする例は配列で登場しました。

要素型 T の配列変数 a の n 番目の要素のアドレスは次の式で計算できます。

　配列 a の先頭要素のアドレス + 型 T の大きさ * n = 対象のアドレス

でしたね。これを悪用してみましょう。


0x1000 を読み書きしたいので、a[n] のアドレスが 0x1000 になると嬉しいですよね


　a[n]のアドレス = 配列 a の先頭要素のアドレス + 型 T の大きさ * n = 0x1000


では、配列 a の先頭要素のアドレス、型 T 、n　をどのように設定すれば良いでしょうか。

色々なパターンがありますが、ここではまず、配列 a の先頭要素のアドレスが0x1000、読み書きしたい要素番号を0としてみましょう。配列の要素型を無視できて簡単ですね。

ではコンパイルしてみましょう
0x1000[0] = ...;
... = 0x1000[0];


0x1000[0] でコンパイラがエラーを起しますね。
なぜなら、上の式の場合、0x1000は整数型であり、U1型の配列型ではないからです。

では、U1型の配列型にキャストすればいいのでしょうか？

やってみましょう

((U1[])0x1000)[0] = ...;
... = ((U1[])0x1000)[0];

エラーになりますね。要素数が無いからでしょうか？

((U1[1])0x1000)[0] = ...;
... = ((U1[1])0x1000)[0];

これでもエラーになります。

なぜでしょうか？
Ｃ言語では配列型へのキャストはできないと規定されているからです。

しかし、Ｃ言語では「式中で使われている配列変数は　型が「【配列の要素の型】のポインタ型＝(【配列の要素の型】*)」である配列の先頭アドレスを示している変数」に読み替えると規定されています。
これは配列型は「【配列の要素の型】のポインタ型＝(【配列の要素の型】*)」と等しいということを示しています

ポインタ型がなんなのかはさておき、0x1000 を U1型の配列型に読み替えたかったのでこれに従い、「U1型のポインタ型＝(U1*)」にキャストしてみましょう

((U1*)0x1000)[0] = ...;
... = ((U1*)0x1000)[0];

コンパイルすると、エラーも警告も出ません。正常にコンパイルされますし、上記の環境のハードウェア上では正常にタイマー機能と通信することが出来ます。

おめでとうございます。これでＣ言語の上でコンパイラとは関係なく、好きなアドレスを好きな型で直接読み書きすることが出来るようになりました。

では最後に、

毎回((U1*)0x1000)と書くのは面倒くさいですね。
マクロとして定義しても良いのですが、ここでは変数 TIMER_PORT として定義してみましょう。

キャスト先の型で変数 TIMER_PORT を定義し、初期化式で((U1*)0x1000)を設定してあげましょう。

U1* TIMER_PORT = ((U1*)0x1000);

と定義できますね。

さてみなさん、ここで、U1*は 「「U1型」のポインタ型」と読みます。
0x1000 は 「アドレス 0x1000 という意味を込めた」整数値ですね。
つまり、「「U1型」のポインタ型」の変数に対して「アドレス 0x1000 という意味を込めた」整数値を設定しています。

ここで、さきほどの配列の特性をもう一度使いましょう。
a[b] は (*(a + b)) と読み替えることができました。これを適用すると

TIMER_PORT[0] = ...; 
... = TIMER_PORT[0];

はそれぞれ

(*(TIMER_PORT + 0)) = ...; 
... = *(TIMER_PORT + 0); 

と読み替えられます

0の加算は何も起きないので、消します。また、無駄な括弧も消します。すると

(*(TIMER_PORT + 0)) = ...; 
... = *(TIMER_PORT + 0); 

は

*TIMER_PORT = ...; 
... = *TIMER_PORT;


おや？配列を使って読み書きする式がいつのまにか「「U1型」のポインタ型＝(U1*)」の変数と単項演算子 * を使って読み書きする式に書き換わりましたね。


さて、皆さん。
ここまでやってきて、ポインタとは何なのでしょうか。

多くの教科書がポインタというもの解説を試みており、Ｃ言語学習の上で最大の障害と言われています。

これはＣ言語におけるポインタというものが複数の概念を示しており、それらがすべて前提知識の上に成り立っているからであり、
前提知識が一つ書けても、ポインタに属する概念を理解することが困難になるからです。

しかし、ここまで学んできた皆さんであれば理解できる下地が出来ています。

ポインタを理解するためには次の知識が必要でした。
・メモリとは何なのか？
　メモリとは、ちょうど１バイトの大きさを持つセルが並んだワークシートのようなもの。
・ＣＰＵがメモリにデータを書き込んだり読み取ったりするにはどのような情報が必要なのか？
　メモリの読み書きする場所を示す番地と読み書きする長さが必要。
　データはバイト列としてメモリに保存される。
　Ｃ言語はどのようにしてメモリを読み書きするための情報をそろえているのか？
　変数の大きさは型情報から求められたサイズを使う。
　配列型、構造体型は型の情報を使って内部のアクセスする領域を指定することが出来る。
　メモリ上のバイト列の解釈方法は型情報を使って決定している。
・Ｃ言語をＣＰＵが実行するにはどうしているのか？
　ＣＰＵはＣ言語を直接実行できないので、コンパイラによって機械語に翻訳される
　変数の読み書きは機械語に翻訳されると、アドレスを指定した読み書き命令に変換される。

ではこれらを踏まえてポインタとは何なのでしょうか？

この勉強会でお伝えしたい上記の答えは次の通りです。

１．概念としてのポインタ：
ポインタの本質はコンピュータのメモリ空間への「直接的な」アクセス

ポインタとは、Ｃ言語の中からプログラマが「任意の」メモリ位置を「直接」指定してアクセスするための機能・仕様の名称です。

ポインタという言語機能が無い場合、Ｃ言語からは特定のアドレスのメモリを読み書きする手段がありません。
元々、Ｃ言語はＵＮＩＸというＯＳを効率よく作るために作られた言語です。
ＯＳを作るためには、ＣＰＵが持つ、割り込み、タイマー、外部通信、汎用ＩＯといった機能をすべて制御できなければならないため、メモリを自由に読み書きできるアセンブリ言語（＝機械語）が用いられていました。
そのため、ＵＮＩＸを開発するために作られたＣ言語にもアセンブリ言語（＝機械語）と同様にメモリを自由に読み書きできる機能が必要でした。
そこで、生まれたのがポインタという言語機能でした。ポインタを使うことで、Ｃ言語はアセンブリ言語（＝機械語）と遜色なく自由にメモリを読み書きできるようになり、そのおかげで組み込みソフトウェア開発のようなハードウェアを細かく制御することが必要な分野で広く使われるようになりました。


２．型システムとしてのポインタ
ポインタはＣ言語の型システムの中に組み込まれた「アドレス値の型」

ＣＰＵがメモリを読み書きするためには、アドレス値と大きさが必要になります。
さらに、メモリ上の値を用いた計算を行うためには、メモリ上の値の解釈方法が必要になります。
Ｃ言語ではこれらの情報のうち、アドレス値は変数の宣言位置（スコープ）から、アドレス値以外は変数の型情報から決定します。

ポインタ型は正確には「〜型へのポインタ型」と定義されています。これは、配列型と同様に「何らかの型を修飾する」ための型であることを示しています。
つまり、Ｃ言語では単独で「ポインタ型」というものは型が無いことになってしまうため存在できません。

そのため、Ｃ言語では「〜型へのポインタ型」とは次の二つの情報を併せ持っています。

・「〜型へのポインタ型」の値は、値をアドレス値として解釈しなければならない整数値である。
・「〜型へのポインタ型」の値をアドレス値として用いる場合、メモリの読み書きで必要となる型情報には「〜型」を使うこととする。

つまり、「〜型へのポインタ型」とは、「〜型として読み書きするアドレス値型」である

「ポインタ型」によって、本来は型を持たない「アドレス値」がＣ言語の型システムの中に上手く組み込まれているのである。


３．オブジェクトの参照としてのポインタ

参照と呼ばれる概念をＣ言語で実現する「テクニック」

Ｃ言語で多用される技法ですが、これはＣ言語独自の機能では無く、１と２の考え方の応用になります。

ＣＰＵがプログラムを実行するとき、命令、変数、定数を全てメモリの上に配置してから実行されます。
つまり、全てのオブジェクトは実行時にはそのオブジェクトを示すアドレスが一意に定まります。

  U8 v = 10; /* v のアドレス値は A とします */
   
ここで、機械語の例で出てきた次のことを思い出してください。
・変数を読み書きする場合、ＣＰＵはその変数に対応するアドレスのメモリ領域を読み書きします。

では質問です。
１．アドレス A の1バイト領域の値はいくつでしょうか？
２．アドレス A の1バイト領域の値を100に書き換えると、変数 v の値はどうなりますか？

１の答えは10です。
２の答えは変数 v の値が100になりますね。

これは、変数 v のアドレス値を知ることが出来れば、変数 v の値は自由に読み書きすることができるということを示しています。

ここで、先ほどの、全てのオブジェクトは実行時にはそのオブジェクトを示すアドレスが一意に定まりますを思い出してください。

これらのことから、アドレスをを知ることが出来れば、全てのオブジェクトを自由に読み書きすることが出来ると言うことになります。

また、アドレス値はポインタ型の変数に値として入れることや、引数や戻り値にすることもできます。
これは、コンパイル時に関数が知らない変数を実行時に操作することが出来ると言うことを示しています。

そして、アドレスを使うことで、「変数」などのオブジェクトそのものを示す（参照する）ことができることを示しています。

この参照という概念はＣ言語に限らず多くのプログラミング言語に登場します。


参照のうれしさ

通常、関数の引数として変数の値を使う場合、その変数の値のコピーが作られて関数中で使われます。
しかし、構造体型や配列型のように複数のデータを内包するもののコピーを作るのは実行時間の悪化やメモリ消費量の悪化に繋がります。特に、関数中で変数の値が読み取りのみしかされない場合はわざわざコピーを作るのが馬鹿らしくなります。

しかし変数を引数に渡す代わりに、変数のアドレスを引数に渡すことで、変数の値のコピーではなく変数に対応するアドレス値のコピーが作られます。変数のアドレス値はほぼ整数型と同じサイズなので、コピーのコストは大きく押さえられます。

