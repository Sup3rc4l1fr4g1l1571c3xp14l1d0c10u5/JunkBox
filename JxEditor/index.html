<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="description" content="" />
    <meta content="noindex, nofollow, noarchive" name="robots" />
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
function isHighSurrogate(x) {
  return 0xD800 <= x && x <= 0xDBFF;
}
function isLoSurrogate(x) {
  return 0xDC00 <= x && x <= 0xDFFF;
}
function isSurrogatePair(high, low) {
  return isHighSurrogate(high) && isLoSurrogate(low);
}
function utf16ToUtf32Char(high, low) {
  if (0x0000 <= high && high <= 0xD7FF) {
    return [1, high];
  } else if (0xE000 <= high && high <= 0xFFFF) {
    return [1, high];
  } else if (0xD800 <= high && high <= 0xDBFF && 0xDC00 <= low && low  <= 0xDFFF) {
    return [2, ((((high >> 6) & 0x0F)+1) << 16) | ((high & 0x3F) << 10) | (low & 0x3FF)];
  } else {
    return [0, undefined];
  }
}
function utf32ToUtf16Char(code) {
  if (0x0000 <= code && code <= 0xD7FF) {
    return [code];
  } else if (0xD800 <= code && code <= 0xDFFF) {
    return undefined;
  } else if (0xE000 <= code && code <= 0xFFFF) {
    return [code];
  } else if (0x10000 <= code && code <= 0x10FFFF) {
    const cp   = code - 0x10000;
    const high = 0xD800 | (cp >> 10);
    const low  = 0xDC00 | (cp & 0x3FF);
    return [high, low];
  } else {
    return undefined;
  }
}
function stringToUtf16(str) {
  const utf16 = [];
  for (let i=0; i<str.length; i++) {
    utf16.push(str.charCodeAt(i));
  }
  return utf16;
}
function utf16ToUtf32(utf16) {
  const utf32 = [];
  for (let i=0; i<utf16.length; ) {
    const [size, code] = utf16ToUtf32Char(utf16[i], utf16[i+1]);
    if (size === undefined) {
      return undefined;
    }
    utf32.push(code);
    i += size;
  }
  return utf32;
}
function utf32ToUtf16(utf32) {
  const utf16 = [];
  for (let i=0; i<utf32.length; i++) {
    const [high, low] = utf32ToUtf16Char(utf32[i]);
    if (high === undefined) {
      return undefined;
    }
    utf16.push(high);
    if (low !== undefined) {
      utf16.push(low);
    }
  }
  return utf16;
}
function utf16ToString(utf16) {
  return String.fromCharCode.apply(null, utf16);
}
function strToUtf32(str) {
  return utf16ToUtf32(stringToUtf16(str));
}
function utf32ToStr(utf32) {
  return utf16ToString(utf32ToUtf16(utf32));
}
class GapBuffer {
  constructor (gapSize) {
    this.gapSize = parseInt(gapSize || 64);
    if (this.gapSize <= 0) {
      throw new RangeError("gapSize must be > 0");
    }
    
    this.buffer     = new Uint32Array(this.gapSize);
    this.gapStart   = 0;
    this.gapEnd     = this.gapSize;
    
    const self = this;
    this[Symbol.iterator] = function*() {
      for (let i=0; i<self.gapStart; i++) {
        yield self.buffer[i];
      }
      for (let i=self.gapEnd; i<self.buffer.length; i++) {
        yield self.buffer[i];
      }
    }
  }
  get(ix) {
    if (ix >= this.length) {
      return undefined;
    }
    if (ix >= this.gapStart) {
      ix += (this.gapEnd - this.gapStart);
    }
    return this.buffer[ix];
  }
  grow(newsize) {
    const gapSize = newsize - this.buffer.length + (this.gapEnd - this.gapStart);
    const newBuffer = new Uint32Array(newsize);
    for (let i=0; i<this.gapStart; i++) {
      newBuffer[i] = this.buffer[i];
    }
    for (let i=this.gapEnd; i<this.buffer.length; i++) {
      newBuffer[i + gapSize] = this.buffer[i];
    }
    this.buffer = newBuffer;
    this.gapEnd = this.gapStart + gapSize;
  }
  insert(ix, value) {
    if (ix < 0) {
      throw new RangeError("insert index must be >= 0");
    }
    if (ix > this.length) {
      throw new RangeError("insert index must be <= length (for now)");
    }
    
    if (this.gapStart === this.gapEnd) {
      this.grow(this.buffer.length + this.gapSize);
    }
    this.moveGap(ix);
    
    this.buffer[this.gapStart++] = value;
  }
  insertAll(ix, values) {
    // TODO: this should be optimised
    for (let i = 0; i < values.length; ++i) {
      this.insert(ix + i, values[i]);
    }
  }
  deleteBefore(ix, len) {
    if (ix === 0 || ix > this.length) {
      return;
    }
    this.moveGap(ix);
    this.gapStart -= len;
    if (this.gapStart < 0)
      this.gapStart = 0;
  }
  clear() {
    this.gapStart = 0;
    this.gapEnd = this.buffer.size;
  }
  asArray() {
    const newBuffer = new Uint32Array(this.length);
    let n = 0;
    for (let i=0; i<this.gapStart; i++, n++) {
      newBuffer[n] = this.buffer[i];
    }
    for (let i=this.gapEnd; i<this.buffer.length; i++, n++) {
      newBuffer[n] = this.buffer[i];
    }
    return newBuffer;
  }
  moveGap(ix) {
    if (ix < this.gapStart) {
      
      const gapSize = (this.gapEnd - this.gapStart);
      const delta = this.gapStart - ix;
          
      for (let i = delta - 1; i >= 0; --i) {
        this.buffer[this.gapEnd - delta + i] = this.buffer[ix + i];
      }
      
      this.gapStart -= delta;
      this.gapEnd -= delta;
    
    } else if (ix > this.gapStart) {
      
      const gapSize = (this.gapEnd - this.gapStart);
      const delta = ix - this.gapStart;
      
      for (let i = 0; i < delta; ++i) {
        this.buffer[this.gapStart + i] = this.buffer[this.gapEnd + i];
      }
      
      this.gapStart += delta;
      this.gapEnd += delta;
    
    }
  }
  
  reduce(callback, initialValue = undefined) {
    let n = 0;
    let i = 0;
    if (initialValue === undefined) {
      initialValue = this.buffer[i];
      n++;
      i++;
    }
    for (; i<this.gapStart; i++, n++) {
      initialValue = callback(initialValue, this.buffer[i], n, this);
    }
    for (i=this.gapEnd; i<this.buffer.length; i++, n++) {
      initialValue = callback(initialValue, this.buffer[i], n, this);
    }
    return initialValue;
  }
  
  find(callback) {
    let n = 0;
    for (let i=0; i<this.gapStart; i++, n++) {
      if (callback(this.buffer[i], n, this) === true) { return this.buffer[i]; }
    }
    for (let i=this.gapEnd; i<this.buffer.length; i++, n++) {
      if (callback(this.buffer[i], n, this)) { return this.buffer[i]; }
    }
    return undefined;
  }
}
Object.defineProperty(GapBuffer.prototype, 'length', {
  enumerable: true,
  get: function() {
    return this.buffer.length - (this.gapEnd - this.gapStart);
  },
});

Array.equal = function (x, y) {
  return x.length === y.length && x.find((n,i)=> y[i] !=n) === undefined
}
class DataViewIterator{
  constructor (arraybuffer, little) {
    this.little = little;
    this.view = new DataView(arraybuffer);
    this.n = 0;
  }
  getUint32() {
    const ret = this.view.getUint32(this.n, this.little);
    this.n += 4;
    return ret;
  }
  getUint8() {
    const ret = this.view.getUint8(this.n);
    this.n += 1;
    return ret;
  }
  getBytes(len) {
    const ret = new Uint8Array(this.view.buffer, this.n, len);
    this.n += len;
    return ret;
  }
}
class BMPFont {
  constructor(arraybuffer) {
    const it = new DataViewIterator(arraybuffer, true);
    this.FourCC         = it.getUint32(),
    this.FontWidth      = it.getUint32(),
    this.FontHeight     = it.getUint32(),
    this.PixelSize      = it.getUint32(),
    this.WidthTableSize = it.getUint32(),
    this.PixelTableSize = it.getUint32(),
    this.WidthTable = [];
    this.PixelTable = [];
    for (let i=0; i<this.WidthTableSize; i++) {
      this.WidthTable.push({
        RangeStart: it.getUint32(),
        RangeEnd  : it.getUint32(),
        Width     : it.getUint8(),
      });
    }
    for (let i=0; i<this.PixelTableSize; i++) {
      const RangeStart = it.getUint32();
      const RangeEnd   = it.getUint32();
      const Pixels     = [];
      for (let i=RangeStart; i<=RangeEnd; i++) {
        Pixels.push(it.getBytes(this.PixelSize));
      } 
      this.PixelTable.push({
        RangeStart: RangeStart,
        RangeEnd  : RangeEnd,
        Pixels    : Pixels,
      });
    }
  }
  search(table,codePoint) {
    let start = 0;
    let end   = table.length-1;
    while (start <= end) {
      const mid = ((end-start)>>1)+start;
      if (table[mid].RangeStart > codePoint) {
        end = mid-1;
      } else if (table[mid].RangeEnd < codePoint) {
        start = mid+1;
      } else {
        return table[mid];
      }
    }
    return undefined;
  }
  getWidth(codePoint) {
    if (0x00 <= codePoint && codePoint <= 0x1F) {
      return 0; // control code
    }
    const ret = this.search(this.WidthTable, codePoint);
    if (ret === undefined) { return undefined; }
    return ret.Width;
  }
  getPixelWidth(codePoint, defaultWidth=undefined) {
    const ret = this.getWidth(codePoint);
    if (ret === undefined) { return index.html; }
    return ret * this.FontWidth ;
  }
  getPixel(codePoint, defaultWidth=undefined) {
    const ret = this.search(this.PixelTable, codePoint);
    if (ret === undefined) { return defaultWidth; }
    return ret.Pixels[codePoint-ret.RangeStart];
  }
  drawStr(x, y, str, pset) {
    this.drawUtf32(x,y,strToUtf32(str), pset);
  }
  drawUtf32(x, y, utf32, pset) {
    let xx = x;
    let yy = y;
    const size   = this.FontHeight;
    const scanline = this.FontHeight;
    for(const ch of utf32) {
      const width = this.getPixelWidth(ch);
      if (width === undefined) {
        xx += this.FontWidth;
        continue;
      }
      if (ch == 0x0A) {
        yy += size;
        xx = x;
        continue;
      } else {
        const pixel = this.getPixel(ch);
        if (pixel) {
          let pSrc = 0;
          for (let j=0; j<size; j++) {
            let p = pSrc;
            for (let i=0; i<size; i++, p++) {
              if (pixel[p >> 3] & (0x80 >> (p & 0x07))) {
                pset(xx+i, yy+j);
              }
            }
            pSrc += scanline;
          }
        }
        xx += width;
      }
    }
  }
}
BMPFont.loadFont = function (url) {
  return new Promise((resolve, reject) => {
    let xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onload = () => {
      if (xhr.readyState === 4 && ((xhr.status === 200) || (xhr.responseURL.startsWith("file://") === true && xhr.status === 0))) {
        resolve(xhr.response);
      } else {
        reject(new Error(xhr.statusText));
      }
    };
    xhr.onerror = () => { reject(new Error(xhr.statusText)); };
    xhr.responseType = 'arraybuffer'
    xhr.send(null);
  }).then((arraybuffer) => {
    return new BMPFont(arraybuffer);
  });
}

class EditorView {
  constructor (font, width, height) {
    this.font = font;
    this.width = width;
    this.height = height;
    this.grid = new Uint32Array(width * height);
  }
  layout(dataCursor) {
    dataCursor = dataCursor.dup();
    for (let y = 0; y<this.height; y++) {
      for (let x = 0; x<this.width; ) {
        let ch = dataCursor.getch();
        let width = this.font.getWidth(ch);
        if (ch === undefined || width === undefined) {
          width = 1;
          ch = 0x00;
        };
        if (this.width < x + width) {
          for (let i = x; i< this.width; i++) {
            this.grid[y * this.width + i] = 0x00;
          }
          break;
        } else if (ch == 0x0A) {
          for (let i = x; i< this.width; i++) {
            this.grid[y * this.width + i] = 0x00;
          }
          dataCursor.nextch();
          break;
        } else {
          this.grid[y * this.width + x] = ch;
          for (let i = 1; i< width; i++) {
            this.grid[y * this.width + x + i] = 0x00;
          }
          x += width;
          dataCursor.nextch();
        }
      }
    }
  }
  calcCursorPos(dataCursor) {
    const dCursor = dataCursor.dup();
    dCursor.row = 0;
    const viewCursor = { column: 0, row: 0 };

    let x = 0;
    while (dCursor.row < dataursor.row) {
      let ch = dCursor.getch();
      let width = this.font.getWidth(ch);
      if (ch === undefined || width === undefined) {
        width = 1;
        ch = 0x00;
      };
      if (this.width < x + width) {
        viewCursor.row = 0;
        viewCursor.column++;
        break;
      } else if (ch == 0x0A) {
        viewCursor.row = 0;
        viewCursor.column++;
        dataCursor.nextch();
        break;
      } else {
        this.grid[y * this.width + x] = ch;
        for (let i = 1; i< width; i++) {
          this.grid[y * this.width + x + i] = 0x00;
        }
        x += width;
        dataCursor.nextch();
      }
    }
    {
      let ch = dCursor.getch();
      let width = this.font.getWidth(ch);
      if (ch === undefined || width === undefined) {
        width = 1;
        ch = 0x00;
      };
      if (this.width < x + width) {
        viewCursor.row = 0;
        viewCursor.column++;
      }
    }
    return viewCursor;
  }
  moveNextLine(dataCursor) {
    dataCursor = dataCursor.dup();
    for (let x = 0; x<this.width; ) {
      let ch = dataCursor.getch();
      let width = this.font.getWidth(ch);
      if (ch === undefined || width === undefined) {
        width = 1;
        ch = 0x00;
      };
      if (this.width < x + width) {
        break;
      } else if (ch == 0x0A) {
        dataCursor.nextch();
        break;
      } else {
        x += width;
        dataCursor.nextch();
      }
    }
    return dataCursor;
  }
  movePrevLine(dataCursor) {
    dataCursor = dataCursor.dup();
    lineViewSize = this.calcCursorPos(dataCursor);
    if (lineViewSize.column == 0) {
      // 前の行へ
      prevLineDataCursor = new DataCursor(dataCursor.column-1, dataCursor.lines[dataCursor.column-1].length, dataCursor.lines);
      prevLineViewSize = this.calcCursorPos(prevLineDataCursor);
      if (prevLineViewSize.row < lineViewSize.row) {
        return prevLineViewSize.row;
      }
    }
  }
}

class DataCursor {
  constructor (column, row, lines) {
    this.column = column;
    this.row = row;
    this.lines = lines;
  }
  getch() {
    if (this.lines.length <= this.column) {
      return undefined;
    }
    if (this.lines[this.column].length == this.row) {
      return 0x0A;
    }
    return this.lines[this.column].get(this.row);
  }
  nextch() {
    if (this.lines.length <= this.column) {
      return false;
    }
    if (this.lines[this.column].length == this.row) {
      this.column++;
      this.row = 0;
      return true;
    }
    this.row++;
    return true;
  } 
  prevch() {
    if (this.lines.length <= this.column) {
      return false;
    }
    if (0 == this.row) {
      if (this.column > 0) {
        this.column--;
        this.row = this.lines.length;
        return true;
      } else {
        return false;
      }
    }
    this.row--;
    return true;
  } 
  dup() {
    return new DataCursor(this.column, this.row, this.lines);
  }
}


window.onload = BMPFont.loadFont("font.bmpf").then((bmpFont) => {
  const docStr = document.getElementsByTagName('script')[0].innerHTML;
  const lines = docStr.split("\n").map(x => {
    const gb = new GapBuffer(16);
    gb.insertAll(0, strToUtf32(x));
    return gb;
  });
  
  const canvas = document.getElementById("canvas");
  const context = canvas.getContext("2d");
  const imageData = context.createImageData(canvas.width, canvas.height);
  const view = new EditorView(bmpFont, ~~(canvas.width / bmpFont.FontWidth), ~~(canvas.height / bmpFont.FontHeight));
  let lefttop = new DataCursor(0, 0, lines);

  function updateAndDraw() {
    view.layout(lefttop);
    imageData.data.fill(0);
    for (let i=0; i<view.height; i++) {
      bmpFont.drawUtf32(0,i*bmpFont.FontHeight,view.grid.subarray(i*view.width,(i+1)*view.width), (x,y) => { 
        if (0 <= y && y < canvas.height && 0 <= x && x < canvas.width) {
          imageData.data[(y*canvas.width+x)*4+3] = 0xFF; 
        }
      }, );
    }
    context.putImageData(imageData,0,0);
  }
  updateAndDraw();
  document.addEventListener("wheel", (e) => {
    if (e.deltaY > 0) {
      lefttop = view.moveNextLine(lefttop);
    }  else {
      lefttop = view.movePrevLine(lefttop);
    }
    updateAndDraw();
  });
});
    </script>
</head>
<body style="margin: 0; padding: 0;">
  <canvas id="canvas" width="600" height="400">
  </canvas>
</body>
</html>
