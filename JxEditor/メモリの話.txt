
２バイト以上のデータをメモリに格納するにはどうしたらいいか？
　1バイト毎に分割して連続したセルに格納する

　0x12345678 => 0x12 0x34 0x56 0x78 と分割して保存
　
　重要：メモリ上ではいかなるデータも１バイトのデータの列で保存される
　　数値：
　　　1バイト毎に分割して連続したセルに格納する
　　文字＝文字コードと呼ばれる文字に対応する数値として保存
　　　'a' = 0x61
　　（C言語における）文字列＝文字列に出現する順番で文字に対応する文字コードが連続してメモリ上に格納される。
　　　　　　　　　　　　　　　さらに、C言語では文字列の末尾に終端を示す0x00が付く。
　　　"hello" = 0x68 0x65 0x6C 0x6C 0x6F 0x00
　　　

メモリの読み書き
メモリを読み書きするときに必要となる情報

メモリ空間の範囲
　先頭位置
　長さ
読み書き時の仕方
　バイトの並び順（バイトオーダー）
　データの見方（ビュー）

バイトの並び順（バイトオーダー）
２バイト以上の場合
　前述するように1バイト単位に分割されている
　　0x12345678 => 0x12 0x34 0x56 0x78 と分割して保存
　メモリに格納する/メモリから読み出す場合にはバイトの並び順を考慮しなければならない
　　ビッグエンディアン：メモリに配置するとき、データの上位バイトから格納する方法
　　　0x12345678 => 0x12, 0x34, 0x56, 0x78 の順でメモリに保存
　　　0x80, 0x00 という並びを２バイトの数値として読み出すと0x8000
　　リトルエンディアン
　　　0x12345678 => 0x78, 0x56, 0x34, 0x12 の順でメモリに保存
　　　0x80, 0x00 という並びを２バイトの数値として読み出すと0x0080
　　
　通常はエンディアンはCPU毎に固定であるため、プログラマが考える必要はあまりない
　　例外として、バイエンディアンと呼ばれるCPUの設定でバイトオーダーを切り替えられるものがある。
　　
　一方、ネットワークプロトコルや、ファイルフォーマットのように別のマシンやCPUとのやりとりで使われるデータ形式の場合は
　そのプロトコルやフォーマット上でバイトオーダーが規定される。
　そのため、バイトオーダーを確認して使わなければ不具合の原因となる。
　　

ここまでのまとめ
・メモリはちょうど１バイトのデータを保存できるセルがスプレッドシートのように並んでおり、
　データを保存するセルには先頭から通し番号（アドレス）が割り振られている。

・メモリ上ではいかなるデータも連続した１バイト単位で保存される
・２バイト以上のデータを保存する場合にはバイトオーダーと呼ばれるバイトの並び順序に気をつける必要がある。

練習問題

次のメモリ上で指定したアドレスの値はそれぞれどうなるか

0x0010 83 00 E7 03 0F 27 64 2F 38 01 00

アドレス 0x0012 から１バイト:
アドレス 0x0012 から２バイト:
 ビッグエンディアンの場合
 リトルエンディアンの場合
アドレス 0x0012 から４バイト:
 ビッグエンディアンの場合
 リトルエンディアンの場合
・
・

データの見方（ビュー）
　前述のようにメモリ上のデータは１バイト単位で格納されているが、
　読み書き範囲と値の読み書き方法を指定しなければならない

C言語においては
　メモリ空間における先頭アドレスで選択範囲の先頭を指定
　型を指定することによって選択範囲の終点と選択範囲に対するビューを同時に指定する。

例：
       +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +a +b +c +d +e +f
0x0020 00 00 1A A4 00 00 01 00 41 42 43 44 45 00 00 28

0x0023を先頭位置としたとき
1バイトの範囲を読み取ると 0xA4 というデータが読み取れる
・これを文字データ(char型の値)と見なすとASCIIコードでは不正文字となるが、ShiftJISコードでは半角の句点 '､' に対応してい
・これを符号無しの数値データ(U1型)と見なすと 0xA4 = 164 になる。
・符号有りの数値データ（S1型）と見なした場合、2の補数表現であれば 0xA4 = 符号ビット と (128 - 36) より -92 となる

同じ数値0xA4であっても、見方によってSJIS文字 '､' と見なすことも、164 と見なすことも -93 と見なすこともできる。

また、0x0028を先頭位置としたとき

1バイトの範囲を読み取ると 0x41 というデータが読み取れる
・これを文字データ(char型の値)と見なすと （ASCII系の文字コード系統における）'A' という文字に対応している
・これを符号無しの数値データ(U1型)と見なすと 0x41 = 65になる。
・符号有りの数値データ（S1型）と見なした場合でも0x41 = 65 となる

2バイトの範囲を読み取ると 0x41 0x42 というデータが読み取れる
・これを符号無しの数値データ(U2型)と見なすと 0x41 0x42 = ビッグエンディアンでは 16706 に、リトルエンディアンでは 16961 となるなる。
・符号有りの数値データ（S2型）と見なした場合は符号ビットが無いため符号無し型の場合と同じ

4バイトの範囲を読み取ると 0x41 0x42 0x43 0x44 というデータが読み取れる
・これを符号無しの数値データ(U4型)と見なすと 0x41 0x42 0x43 0x44 = ビッグエンディアンでは 0x41424344 = 1094861636 に、リトルエンディアンでは 0x44434241 = 1145258561 となるなる。
・符号有りの数値データ（S4型）の場合は符号ビットが無いため符号無し型の場合と同じ
・浮動小数点数(float)の場合、781.0352172851562 となる
・先頭位置はそのままで文字列データと見なした場合、これは５バイトから構成される文字列で "ABCD"  となる

このように、読み書き範囲に咥えて、値をどのように解釈するかによって値の意味が決まる。
この値をどのように解釈するかという部分はC言語においては型によって定まる。


型
プログラミング言語においては二つの意味を持つ
データ型：値（データ）の種類に関する分類。
　
型システム：式などの部分が持つ値を、その種類（データ型）に沿って分類し、プログラムが正しく振る舞うこと、といった性質について保証する手法








